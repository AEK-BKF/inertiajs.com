import dedent from 'dedent'
import Layout from '../components/Layout'
import TabbedCodeExamples from '../components/TabbedCodeExamples'

export default Layout
export const meta = {
  title: 'Routing',
  links: [
    { url: '#top', name: 'Routing' },
    { url: '#responses', name: 'Responses' },
    { url: '#redirects', name: 'Redirects' },
  ],
}

# Routing

With Inertia all routing is defined server-side. Meaning you don't need Vue Router or React Router. Simply create routes using your server-side framework of choice.

## Responses

The magic of Inertia is in the server-side responses. On the first page load, a full `html` response is returned from the server. This includes your site assets and a root `div`. The root div includes a `data-page` attribute, which includes a `json` encoded version of the current (JavaScript) page component name, it's props (data), the current page url, and the asset version. Inertia uses this to boot your JavaScript application.

```twig
<html>
<head>
    <title>My app</title>
    <link href="/css/app.css" rel="stylesheet">
    <script src="/js/app.js" defer></script>
</head>
<body>

<div id="app" data-page="{&quot;component&quot;:&quot;Event&quot;,&quot;props&quot;:{&quot;event&quot;:{&quot;id&quot;:80,&quot;title&quot;:&quot;Birthday party&quot;,&quot;start_date&quot;:&quot;2019-06-02&quot;,&quot;description&quot;:&quot;Come out and celebrate Jonathan's 36th birthday party!&quot;}},&quot;url&quot;:&quot;/events/80&quot;,&quot;version&quot;:&quot;c32b8e4965f418ad16eaebba1d4e960f&quot;}"></div>

</body>
</html>
```

Since Inertia is a framework for building single-page applications, all subsequent page visits are made as `xhr` requests. That means subsequent responses must be handled differently.

Rather than returning a full `html` response like the first page load, instead make a `json` response with just the page data. This `json` response should be in the exact same format as the `json` encoded in the `data-page` attribute.

```json
{
  "component": "Event",
  "props": {
    "event": {
      "id": 80,
      "title": "Birthday party",
      "start_date": "2019-06-02",
      "description": "Come out and celebrate Jonathan's 36th birthday party!"
    }
  },
  "url": "/events/80",
  "version": "c32b8e4965f418ad16eaebba1d4e960f"
}
```

Inertia responses must have the `Vary` header set to `Accept` and the `X-Inertia` header set to `true`.

You can detect incoming Inertia requests by checking the `X-Inertia` header, which will be set to `true`. It will also include a `X-Inertia-Version` header, which you can learn more about on the [asset versioning](/asset-versioning) page.

Of course, all this work can be avoided by simply using a server-side adapter, such as the [Laravel adapter](/server-side-setup#laravel).

<TabbedCodeExamples
  examples={[
    {
      name: 'Laravel',
      language: 'php',
      code: dedent`
        use Inertia\Inertia;\n
        class EventsController extends Controller
        {
            public function show(Event $event)
            {
                return Inertia::render('Event', [
                    'event' => $event->only(
                        'id',
                        'title',
                        'start_date',
                        'description'
                    ),
                ]);
            }
        }
      `,
    },
  ]}
/>

## Redirects

When making a non-GET Inertia request, via `<inertia-link>` or manually, be sure to still respond with a proper Inertia response. For example, if you're creating a new user, have your "store" endpoint return a redirect back to a standard GET endpoint, such as your user index page. Inertia will automatically follow this redirect and update the page accordingly. Here's a simplified example.

```php
class UsersController extends Controller
{
    public function index()
    {
        return Inertia::render('Users/Index', ['users' => User::all()]);
    }

    public function store()
    {
        User::create(
            Request::validate([
                'first_name' => ['required', 'max:50'],
                'last_name' => ['required', 'max:50'],
                'email' => ['required', 'max:50', 'email'],
            ])
        );

        return Redirect::route('users');
    }
}
```

Note, when redirecting after a `PUT`, `PATCH` or `DELETE` request you must use a `303` response code, otherwise the subsequent request will not be treated as a `GET` request. A `303` redirect is the same as a `302` except that the follow-up request is explicitly changed to a `GET` request.
